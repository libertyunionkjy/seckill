## 项目总结

### 这个项目实现了什么？

#### 秒杀项目的框架搭建

1. SpringBoot
2. Thymeleaf，RespBean
3. Mybatis

#### 分布式对话

1. 用户登陆
    1. 设计数据库
    2. 明文密码二次MD5加密
    3. 参数校验+全局异常处理
2. 共享Session
    1. SpringSession
    2. Redis

#### 功能开发

1. 商品列表
2. 商品详情
3. 秒杀
4. 订单详情

#### 系统压测

1. JMeter
2. 自定义变量模拟多用户
3. JMeter命令行的使用
4. 正式压测
    1. 商品列表
    2. 秒杀接口

#### 页面优化

1. 页面缓存+对象缓存；
2. 页面静态化（商品详情页，订单详情页）

#### 接口优化

1. Redis预减库存减少数据库访问
2. 内存标记减少Redis访问
3. RabbitMQ流量削峰

#### 安全优化

1. 秒杀接口地址隐藏
2. 算术验证码
3. 接口限流

### 架构原则：“4 要 1 不要”

1.数据尽量少：用户请求的数据能少就少。请求的数据包括上传给系统的数据和系统返回给用户的数据（通常就是网页）。例如，我们可以简化秒杀页面的大小，去掉不必要的页面装修效果，等等；

2.请求数尽量少：页面依赖的 CSS/JavaScript、图片，以及 Ajax 请求等等都定义为“额外请求”，这些额外请求应该尽量少。例如，减少请求数最常用的一个实践就是合并 CSS 和 JavaScript 文件，把多个 JavaScript 文件合并成一个文件；

3.路径尽量短：缩短请求路径不仅可以增加可用性，同样可以有效提升性能（减少中间节点可以减少数据的序列化与反序列化），并减少延时（可以减少网络传输耗时）。要缩短访问路径有一种办法，就是多个相互强依赖的应用合并部署在一起，把远程过程调用（RPC）变成 JVM 内部之间的方法调用。

4.依赖尽量少：举个例子，比如说你要展示秒杀页面，而这个页面必须强依赖商品信息、用户信息，还有其他如优惠券、成交列表等这些对秒杀不是非要不可的信息（弱依赖），这些弱依赖在紧急情况下就可以去掉。

5.不要有单点：避免将服务的状态和机器绑定，即把服务无状态化，这样服务就可以在机器中随意移动。例如把和机器相关的配置动态化，这些参数可以通过配置中心来动态推送，在服务启动时动态拉取下来，我们在这些配置中心设置一些规则来方便地改变这些映射关系。

### 优化的实际案例演进方向

以实际的一个秒杀系统的演进为例：

#### 1、普通秒杀

快速搭建一个简单的秒杀系统，只需要把你的商品购买页面增加一个“定时上架”功能，仅在秒杀开始时才让用户看到购买按钮，当商品的库存卖完了也就结束了。

#### 2、单独分离秒杀系统

到10w/s的请求量的时候，做新的架构演变：

1. 把秒杀系统独立出来单独打造一个系统，这样可以有针对性地做优化，例如这个独立出来的系统就减少了店铺装修的功能，减少了页面的复杂度；
2. 在系统部署上也独立做一个机器集群，这样秒杀的大流量就不会影响到正常的商品购买集群的机器负载；
3. 将热点数据（如库存数据）单独放到一个缓存系统中，以提高“读性能”；
4. 增加秒杀答题，防止有秒杀器抢单。

最重要的就是，秒杀详情成为了一个独立的新系统，另外核心的一些数据放到了缓存（Cache）中，其他的关联系统也都以独立集群的方式进行部署。

#### 3、升级秒杀系统

超过 100w/s 的请求量，架构优化：

1. 对页面进行彻底的动静分离，使得用户秒杀时不需要刷新整个页面，而只需要点击抢宝按钮，借此把页面刷新的数据降到最少；
2. 在服务端对秒杀商品进行本地缓存，不需要再调用依赖系统的后台服务获取数据，甚至不需要去公共的缓存集群中查询数据，这样不仅可以减少系统调用，而且能够避免压垮公共缓存集群。
3. 增加系统限流保护，防止最坏情况发生。

经过这些优化，系统架构变成了下图中的样子。在这里，我们对页面进行了进一步的静态化，秒杀过程中不需要刷新整个页面，而只需要向服务端请求很少的动态数据。而且，最关键的详情和交易系统都增加了本地缓存，来提前缓存秒杀商品的信息，热点数据库也做了独立部署，等等。

### 系统优化的三个方面

秒杀对应到架构设计，其实就是高可用、一致性和高性能的要求：

- 高性能。 秒杀涉及高读和高写的支持，如何支撑高并发，如何抵抗高IOPS？核心优化理念其实是类似的：高读就尽量"少读"或"读少"，高写就数据拆分。本文将从**动静分离、热点优化以及服务端性能优化** 3 个方面展开
- 一致性。 秒杀的核心关注是商品库存，有限的商品在同一时间被多个请求同时扣减，而且要保证准确性，显而易见是一个难题。如何做到既不多又不少？
- 高可用。 大型分布式系统在实际运行过程中面对的工况是非常复杂的，业务流量的突增、依赖服务的不稳定、应用自身的瓶颈、物理资源的损坏等方方面面都会对系统的运行带来大大小小的的冲击。如何保障应用在复杂工况环境下还能高效稳定运行，如何预防和面对突发问题，系统设计时应该从哪些方面着手？

### 高性能

#### 动静分离

> 首先明确一下什么是静态数据：所谓“动态”还是“静态”，并不是说数据本身是否动静，而是数据中是否含有和访问者相关的个性化数据。页面中“不包含”，指的是“页面的 HTML 源码中不含有”，这一点务必要清楚。

对页面进行静态化改造，即数据意义上的动静分离。动静分离三步走：1、数据拆分；2、静态缓存；3、数据整合。

数据拆分：什么样的数据需要进行动态的异步

静态缓存：

* 怎么缓存？缓存整个HTTP链接，根据URL返回对应的响应体，无需重组请求头。
* 缓存到哪儿？1.浏览器；**2.CDN；**3.服务端；应该根据情况，把它们尽量缓存到离用户最近的地方。
* 数据整合

> 暴力的静态化改造：相较于普通的数据缓存而言，你肯定还听过系统的静态化改造。静态化改造是直接缓存 HTTP 连接而不是仅仅缓存数据，Web 代理服务器根据请求 URL，直接取出对应的 HTTP 响应头和响应体然后直接返回，这个响应过程简单得连 HTTP 协议都不用重新组装，甚至连 HTTP 请求头也不需要解析。

#### 热点优化

热点操作：阻断用户频繁刷新页面

热点数据三步走：1、热点识别；2、热点隔离；3、热点优化

* 热点识别：热点数据的采集最好采用异步的方式，，热点发现最好做到秒级时延。
* 热点隔离：不要让1%的数据影响到另外99%的数据，目的都是把已经识别的热点请求和普通请求区分开来。
* 热点优化：缓存、限流

#### 系统优化

代码层面的性能优化

1. 减少序列化（减少远程的RPC调用）
2. 直接输出流数据
3. 裁剪日志的异常堆栈
4. 去组件框架

### 一致性

减库存的方式有三种，下单减库存、付款减库存、预减库存

1. 下单减库存：最精确的方式，用户体验最好，不能防范恶意下单锁库存
2. 付款减库存：可以保证实际售卖，用户体验较差
3. 预扣库存：下单的时候预扣库存，库存为其保留一定的时间，超过时间库存自动释放

实际的时候使用预扣库存的方案，恶意下单的情况主要还是靠安全和反作弊措施来制止。

怎么防止超卖？库存超卖的情况可以通过：1、使用数据库事务；2、设置数据库字段类型为无符号整数；

> **读写库存这个操作怎么优化？**
>
> 可以想像得到“库存”在秒杀的场景下必然是个热点数据，我们需要花很多精力在优化库存的读写操作上面。
>
> * 库存读：
    >
    >   秒杀场景解决高并发读问题，关键词是“分层校验”。秒杀中并不需要对库存有精确的一致性读，把库存数据放到缓存（Cache）中，可以大大提升读性能。另外还可以采用 LocalCache（即在秒杀系统的单机上缓存商品相关的数据）和对数据进行分层过滤的方式
>
> * 库存写
    >   * 更换DB选型：首先考虑，如果减库存的逻辑很单一，不涉及复杂的SKU库存和总库存这种联动关系，是完全可以把减库存的逻辑放到缓存系统上实现的。
>   * 优化DB性能

### 高可用

#### 流量削峰

1. 使用消息队列，但是如果流量很大，也会冲垮消息服务器；

2. 答题，一是为了防止作弊，二是为了延缓请求

3. 分层过滤：假如请求分别经过 CDN、前台读系统（如商品详情系统）、后台系统（如交易系统）和数据库这几层，那么：

    - 大部分数据和流量在用户浏览器或者 CDN 上获取，这一层可以拦截大部分数据的读取；
    - 经过第二层（即前台系统）时数据（包括强一致性的数据）尽量得走 Cache，过滤一些无效的请求；
    - 再到第三层后台系统，主要做数据的二次检验，对系统做好保护和限流，这样数据量和请求就进一步减少；
    - 最后在数据层完成数据的强一致性校验。

   这样就像漏斗一样，尽量把数据量和请求量一层一层地过滤和减少了。

### 参考资料

[如何设计一个秒杀系统](http://www.lichengblog.com/rhsjygmsxt/274.jhtml)
